<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USB Device Middleware Library 2.10: USB Device Middleware Library 2.10</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USB Device Middleware Library 2.10</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">USB Device Middleware Library 2.10 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The USB Device middleware provides a full-speed USB 2.0 Chapter 9 specification -compliant device framework. It uses the USBFS driver from PDL to interface with the hardware. The middleware provides support for Audio, CDC, and HID classes. Also, it allows implementing other class support. The USB Configurator tool makes it easy to construct the USB Device descriptor.</p>
<p><b>Features:</b></p><ul>
<li>USB Full-Speed Device Framework</li>
<li><a class="el" href="index.html#group_usb_dev_cfg_tool">USB Configurator</a></li>
<li>The following USB Classes are supported:<ul>
<li><a class="el" href="index.html#group_usb_dev_audio_class_info">Audio Class</a></li>
<li><a class="el" href="index.html#group_usb_dev_cdc_class_info">CDC: Communication Device Class</a></li>
<li><a class="el" href="index.html#group_usb_dev_hid_class_info">HID: Human Interface Device</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="section_usb_dev_general"></a>
General Description</h1>
<p>The USB Device structure is divided into layers. The implementation is event-driven: the USBFS driver receives interrupts from the hardware and provides callbacks to the USB Device layer which implements them and provides events to the Class layer. A simplified image is shown below. <br />
 <br />
</p><div class="image">
<img src="usb_dev_solution_struct.png" alt="usb_dev_solution_struct.png"/>
</div>
<p>Include cy_usb_dev.h along with the header for the USB class to be used (cy_usb_dev_hid.h, cy_usb_dev_cdc.h, cy_usb_dev_audio.h) to get access to all the functions and other declarations in this library. If you use ModusToolbox USB Device Configurator, also include cycfg_usbdev.h.</p>
<h1><a class="anchor" id="section_usb_dev_quick_start"></a>
Quick Start Guide</h1>
<p>Cypress USB Device middleware can be used in various software environments. Refer to the <a class="el" href="index.html#section_usb_dev_toolchain">Supported Software and Tools</a>. The quickest way to get started is using the Code Examples. Cypress Semiconductor continuously extends its portfolio of code examples at <a href="http://www.cypress.com"><b>Cypress Semiconductor website</b></a> and at <a href="https://github.com/cypresssemiconductorco"><b>Cypress Semiconductor GitHub</b></a>.</p>
<p>This quick start guide is for an environment configured to use for development MTB CAT1A Peripheral Driver Library (PSoC6) or MTB CAT2 Peripheral Driver Library (PSoC4 &amp; PMG1) included in the project.</p>
<p>To easily run a USB, use the ModusToolbox USBCommDevice or USBM project. The steps below show how to set up a USB Device based on a basic ModusToolbox project (like Hello_World).</p>
<p>The following steps set up a USB device recognized as an standard HID device - USB mouse and moves it from right to the left, and vice-versa. </p><dl class="section note"><dt>Note</dt><dd>Some steps contain a corresponding to the figure below number in brackets.</dd></dl>
<h2><a class="anchor" id="subsection_qsg_step1"></a>
STEP 1: Enable the USB Device middleware.</h2>
<p>Launch ModusToolbox Library Manager and enable the USB Device middleware. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure the USB Device Middleware is included in your project.</p>
<h2><a class="anchor" id="subsection_qsg_step2"></a>
STEP 2: Generate initialization code.</h2>
<ol type="1">
<li>Launch the ModusToolbox Device Configurator Tool and switch to the Peripherals tab (#1.1).</li>
<li>Enable the USB personality under Communication and enter Alias (#1.2). We use USBHID in <a class="el" href="index.html#section_usb_dev_quick_start">Quick Start Guide</a></li>
<li>Go to the Parameters pane and configure the USB personality: assign the peripheral clock divider (#1.3) for Clock (Bus Reset). Any available free divider can be used. This is not required to be done for the PMG1 family of devices.</li>
<li>Set Endpoint Mask to 1 to enable data endpoint 1 (#1.4) Enabled data endpoints must match the descriptor tree in the USB Configurator. <div class="image">
<img src="usb_dev_device_cfg.png" alt="usb_dev_device_cfg.png"/>
</div>
</li>
<li>Switch to the System tab (#2.1).</li>
<li>Check the IMO clock is enabled (#2.2). Select Trim with USB (#2.3)</li>
<li>Select one of the PLLs, if your device supports more than one. Enable the PLL and set a frequency of 48 MHz (#2.4).</li>
<li>Select the CLK_HF3 USB clock (#2.5). Assign the source clock to the CLK_PATH connected to the configured previously PLL.<br />
 (Not required for PMG1 devices) (#2.6).</li>
<li>Check the FLL clock is enabled (Not required for PMG1 devices) (#2.7).</li>
<li>Select File-&gt;Save to generate initialization code. <div class="image">
<img src="usb_dev_system_cfg.png" alt="usb_dev_system_cfg.png"/>
</div>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step3"></a>
STEP 3: Generate USB descriptors.</h2>
<ol type="1">
<li>Run the USB Configurator.</li>
<li>In the Device Descriptor node, set bDeviceClass - 0x02(#3.1), iProduct - the device name to identify among connected devices. We use "USB Device Quick Start guide"(#3.2).</li>
<li>Remove default Alternate Settings.</li>
<li>Add HID Alternate Settings.</li>
<li>Add HID Descriptor and select 3-Button Mouse in HID Report (#3.3).</li>
<li>Add Endpoint Descriptor and set: direction - IN, Transfer Type - Interrupt, wMaxPacketSize - 3, bInterval - 10(#3.4).</li>
<li>Perform File-&gt;Save to generate initialization code. If configuration is saved for the first time, choose a name (like design.cyusbdev) and save it to the project root. <div class="image">
<img src="usb_dev_configurator.png" alt="usb_dev_configurator.png"/>
</div>
</li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step4"></a>
STEP 4: Update main.c</h2>
<ol type="1">
<li>Include the USB headers to get access to the generated descriptor structures, USB driver, device, and class layers APIs. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cy_pdl.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cy_usb_dev.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;cy_usb_dev_audio.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cy_usb_dev_cdc.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cy_usb_dev_hid.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;cycfg_usbdev.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cycfg.h&quot;</span></div></div><!-- fragment --></li>
<li>Declare the USB context global variables: <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Global constants</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line">cy_stc_usbfs_dev_drv_context_t      USBHID_context;</div><div class="line"><a class="code" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>            USBHID_devContext;</div><div class="line"><a class="code" href="structcy__stc__usb__dev__hid__context__t.html">cy_stc_usb_dev_hid_context_t</a>        USBHID_hidContext;</div></div><!-- fragment --></li>
<li>Configure the USB interrupt structures and declare interrupt handlers (refer to the Configure Interrupts section of the USBFS driver in the PDL API Reference). <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* USBFS interrupts functions and configurations</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrLow(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrMedium(<span class="keywordtype">void</span>);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrHigh(<span class="keywordtype">void</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t USBD_IntrHighConfig =</div><div class="line">{</div><div class="line">    .intrSrc = (IRQn_Type) usb_interrupt_hi_IRQn,</div><div class="line">    .intrPriority = 5U,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t USBD_IntrMeduimConfig =</div><div class="line">{</div><div class="line">    .intrSrc = (IRQn_Type) usb_interrupt_med_IRQn,</div><div class="line">    .intrPriority = 6U,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t USBD_IntrLowConfig =</div><div class="line">{</div><div class="line">    .intrSrc = (IRQn_Type) usb_interrupt_lo_IRQn,</div><div class="line">    .intrPriority = 7U,</div><div class="line">};</div></div><!-- fragment --></li>
<li>Implement the interrupt handlers: <div class="fragment"><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: USBD_IsrHigh</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrHigh(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Call interrupt processing */</span></div><div class="line">    Cy_USBFS_Dev_Drv_Interrupt(USBHID_HW, Cy_USBFS_Dev_Drv_GetInterruptCauseHi(USBHID_HW), </div><div class="line">                               &amp;USBHID_context);</div><div class="line">}</div><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: USBD_IsrMedium</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrMedium(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Call interrupt processing */</span></div><div class="line">    Cy_USBFS_Dev_Drv_Interrupt(USBHID_HW, Cy_USBFS_Dev_Drv_GetInterruptCauseMed(USBHID_HW), </div><div class="line">                               &amp;USBHID_context);</div><div class="line">}</div><div class="line"><span class="comment">/*******************************************************************************</span></div><div class="line"><span class="comment">* Function Name: USBD_IsrLow</span></div><div class="line"><span class="comment">*******************************************************************************/</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> USBD_IsrLow(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Call interrupt processing */</span></div><div class="line">    Cy_USBFS_Dev_Drv_Interrupt(USBHID_HW, Cy_USBFS_Dev_Drv_GetInterruptCauseLo(USBHID_HW), </div><div class="line">                               &amp;USBHID_context);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Update the main() function with the USB and interrupt initialization routines: <div class="fragment"><div class="line">    <a class="code" href="group__group__usb__dev__enums.html#ga143c13515bfded27b9dc5ebc18d4cdaf">cy_en_usb_dev_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize device hardware */</span></div><div class="line">    init_cycfg_all();</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize USB */</span></div><div class="line">    status = <a class="code" href="group__group__usb__dev__functions__common.html#ga12b36659b72aa85166e85323eb96e36a">Cy_USB_Dev_Init</a>(USBHID_HW, &amp;USBHID_config, &amp;USBHID_context,</div><div class="line">                             &amp;usb_devices[0], &amp;usb_devConfig, &amp;USBHID_devContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__usb__dev__enums.html#gga143c13515bfded27b9dc5ebc18d4cdafabf8d747d814384b26bf7e65e59648744">CY_USB_DEV_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Initialization error - stop execution */</span></div><div class="line">        <span class="keywordflow">while</span>(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__usb__dev__hid__functions.html#ga96ac1be9fe988572712f3111180170bb">Cy_USB_Dev_HID_Init</a>(&amp;usb_hidConfig, &amp;USBHID_hidContext, &amp;USBHID_devContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__usb__dev__enums.html#gga143c13515bfded27b9dc5ebc18d4cdafabf8d747d814384b26bf7e65e59648744">CY_USB_DEV_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* HID Initialization error - stop execution */</span></div><div class="line">        <span class="keywordflow">while</span>(1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routines */</span></div><div class="line">    (void) Cy_SysInt_Init(&amp;USBD_IntrLowConfig,    &amp;USBD_IsrLow);</div><div class="line">    (void) Cy_SysInt_Init(&amp;USBD_IntrMeduimConfig, &amp;USBD_IsrMedium);</div><div class="line">    (void) Cy_SysInt_Init(&amp;USBD_IntrHighConfig,   &amp;USBD_IsrHigh);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupts */</span></div><div class="line">    NVIC_EnableIRQ((IRQn_Type) USBD_IntrLowConfig.intrSrc);</div><div class="line">    NVIC_EnableIRQ((IRQn_Type) USBD_IntrMeduimConfig.intrSrc);</div><div class="line">    NVIC_EnableIRQ((IRQn_Type) USBD_IntrHighConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupts */</span></div><div class="line">    __enable_irq();</div><div class="line"></div><div class="line">    <span class="comment">/* Make device appear on the bus */</span></div><div class="line">    <a class="code" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a>(<span class="keyword">true</span>, <a class="code" href="group__group__usb__dev__macros.html#gad8a978b86bb53dd8e46d9f9db9399ee8">CY_USB_DEV_WAIT_FOREVER</a>, &amp;USBHID_devContext);</div></div><!-- fragment --></li>
<li>Example of the routine to move mouse from right to the left, and vice-versa. <div class="fragment"><div class="line">    <span class="keyword">const</span> uint32_t CURSOR_X_POS     =   1UL;</div><div class="line">    <span class="keyword">const</span> uint32_t MOUSE_DATA_LEN   =   3UL;</div><div class="line">    <span class="keyword">const</span> uint32_t MOUSE_IN_EP      =   1UL;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint8_t  CURSOR_STEP      =   5U;</div><div class="line">    <span class="keyword">const</span> uint32_t STEPS_NUMBER     =   96UL;</div><div class="line"></div><div class="line">    uint8_t counter = 0U;</div><div class="line">    <span class="keywordtype">bool</span> moveRight = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Mouse packet array: buttons (1st byte), X (2nd byte), Y (3rd byte) */</span></div><div class="line">    <a class="code" href="group__group__usb__dev__macros.html#ga0ccd70a937ab3d69aeb40030713bc69b">CY_USB_DEV_ALLOC_ENDPOINT_BUFFER</a>(mouseData, 3U);</div><div class="line">    mouseData[2U] = 0U; <span class="comment">/* No changes in Y - position */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Move mouse to the right or to the left appropriate number of steps */</span></div><div class="line">        mouseData[CURSOR_X_POS] = moveRight ? CURSOR_STEP : (uint8_t)-CURSOR_STEP;</div><div class="line"></div><div class="line">        <span class="comment">/* Define direction of the movement */</span></div><div class="line">        <span class="keywordflow">if</span> (0U == counter)</div><div class="line">        {</div><div class="line">            counter = STEPS_NUMBER;</div><div class="line">            moveRight = !moveRight;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Update mouse position */</span></div><div class="line">        <a class="code" href="group__group__usb__dev__functions__data__transfer.html#ga1bf916540d58d458568b2eed1a186df4">Cy_USB_Dev_WriteEpBlocking</a>(MOUSE_IN_EP, mouseData, MOUSE_DATA_LEN,</div><div class="line">                                    <a class="code" href="group__group__usb__dev__macros.html#gad8a978b86bb53dd8e46d9f9db9399ee8">CY_USB_DEV_WAIT_FOREVER</a>, &amp;USBHID_devContext);</div><div class="line">        counter--;</div><div class="line">        Cy_SysLib_Delay(10UL);</div><div class="line">    }</div></div><!-- fragment --> </li>
</ol>
<h2><a class="anchor" id="subsection_qsg_step5"></a>
STEP 5: Build and program the device.</h2>
<p>Connect the device to the Host PC. On the PC, verify a new USB device was enumerated as a mouse device. The mouse's cursor shall move left to right and vice-versa.</p>
<h1><a class="anchor" id="group_usb_dev_configuration"></a>
Configuration Considerations</h1>
<p>This section explains how to configure the USB Device for operation.</p>
<h2><a class="anchor" id="group_usb_dev_config_drv"></a>
Configure USBFS driver</h2>
<p>The driver and system resources configuration details are provided in the USBFS driver section Configuration Considerations in the PDL API Reference Manual. The provided code snippets expect that driver and system resources configuration is done.</p>
<h2><a class="anchor" id="group_usb_dev_config_descr"></a>
Construct USB Device Descriptors</h2>
<p>Run standalone USB Configurator tool to construct the USB Device descriptors. After USB Device descriptors are constructed, save generated source and header files. Add these files to your project. Open header files to get external definitions for:</p><ul>
<li>USB Device configuration structure <a class="el" href="structcy__stc__usb__dev__config__t.html">cy_stc_usb_dev_config_t</a> instance.</li>
<li>Array of USB Devices structures <a class="el" href="structcy__stc__usb__dev__device__t.html">cy_stc_usb_dev_device_t</a>.</li>
<li>CDC and/or HID class configuration structure instances.</li>
</ul>
<p>These definitions will be required in the configuration steps provided below.</p>
<h2><a class="anchor" id="group_usb_dev_config"></a>
Configure USB Device</h2>
<p>To initialize the USB Device middleware, call <a class="el" href="group__group__usb__dev__functions__common.html#ga12b36659b72aa85166e85323eb96e36a">Cy_USB_Dev_Init</a> function providing:</p><ul>
<li>The pointer to the USBFS instance.</li>
<li>The pointer to the filled USBFS driver configuration structure cy_stc_usbfs_dev_drv_config_t.</li>
<li>The pointer to the allocated USBFS driver context structure cy_stc_usbfs_dev_drv_context_t.</li>
<li>The pointer to the generated middleware USB Device structure <a class="el" href="structcy__stc__usb__dev__device__t.html">cy_stc_usb_dev_device_t</a>.</li>
<li>The pointer to the generated middleware USB Device configuration structure <a class="el" href="structcy__stc__usb__dev__config__t.html">cy_stc_usb_dev_config_t</a>.</li>
<li>The pointer to the allocated middleware USB Device context structure <a class="el" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>.</li>
</ul>
<h2><a class="anchor" id="group_usb_dev_config_class"></a>
Configure USB Classes</h2>
<p>The USB Device middleware provides support of Audio, HID, and CDC classes. Each class has own initialization function. This function must be called after <a class="el" href="group__group__usb__dev__functions__common.html#ga12b36659b72aa85166e85323eb96e36a">Cy_USB_Dev_Init</a> to initialize class data and register it. The class-specific request will be passed to the class handler after registration. Note that the USB Configurator tool generates HID and CDC Class configuration structures that are required class initialization. Find these structure external declaration in the generated header file.</p>
<p>To initialize the Audio Class, call <a class="el" href="group__group__usb__dev__audio__functions.html#ga8224694c94d72e5c3e2d717bd3a70f3c">Cy_USB_Dev_Audio_Init</a> function providing:</p><ul>
<li>The NULL pointer (reserved for possible future use).</li>
<li>The pointer to the allocated Audio Class context structure <a class="el" href="structcy__stc__usb__dev__audio__context__t.html">cy_stc_usb_dev_audio_context_t</a>.</li>
<li>The pointer to the allocated USB Device context structure <a class="el" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>.</li>
</ul>
<p>To initialize the CDC Class, call <a class="el" href="group__group__usb__dev__cdc__functions.html#ga674860e659c0f23538a9f6c11e64b03a">Cy_USB_Dev_CDC_Init</a> function providing:</p><ul>
<li>The pointer to the populated CDC Class configuration structure <a class="el" href="structcy__stc__usb__dev__cdc__config__t.html">cy_stc_usb_dev_cdc_config_t</a>.</li>
<li>The pointer to the allocated CDC Class context structure <a class="el" href="structcy__stc__usb__dev__cdc__context__t.html">cy_stc_usb_dev_cdc_context_t</a>.</li>
<li>The pointer to the allocated USB Device context structure <a class="el" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>.</li>
</ul>
<p>To initialize the HID Class, call <a class="el" href="group__group__usb__dev__hid__functions.html#ga96ac1be9fe988572712f3111180170bb">Cy_USB_Dev_HID_Init</a> function providing:</p><ul>
<li>The pointer to the populated HID Class configuration structure <a class="el" href="structcy__stc__usb__dev__hid__config__t.html">cy_stc_usb_dev_hid_config_t</a>.</li>
<li>The pointer to the allocated HID Class context structure <a class="el" href="structcy__stc__usb__dev__hid__context__t.html">cy_stc_usb_dev_hid_context_t</a>.</li>
<li>The pointer to the allocated USB Device context structure <a class="el" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>.</li>
</ul>
<h2><a class="anchor" id="group_usb_dev_config_enable"></a>
Enable USB Device</h2>
<p>Finally, enable the USB Device operation calling <a class="el" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a>. This function call enables pull-up on D+ to signal USB Device connection on USB Bus. The USB Host detects device connection and starts device enumeration. It requests the device descriptors to define device capabilities and finally sets device configuration for the following operation. The <a class="el" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a> provides an argument to block until enumeration completes or exits after the USB Device is enabled.</p>
<div class="fragment"><div class="line"><span class="comment">/* Allocate required context structures */</span></div><div class="line">cy_stc_usbfs_dev_drv_context_t USBD_drvContext;</div><div class="line"></div><div class="line"><a class="code" href="structcy__stc__usb__dev__context__t.html">cy_stc_usb_dev_context_t</a>       USBD_devContext;</div><div class="line"><a class="code" href="structcy__stc__usb__dev__audio__context__t.html">cy_stc_usb_dev_audio_context_t</a> USBD_audioContext;</div><div class="line"><a class="code" href="structcy__stc__usb__dev__cdc__context__t.html">cy_stc_usb_dev_cdc_context_t</a>   USBD_cdcContext;</div><div class="line"><a class="code" href="structcy__stc__usb__dev__hid__context__t.html">cy_stc_usb_dev_hid_context_t</a>   USBD_hidContext;</div><div class="line"></div><div class="line"><span class="comment">/* Initialize USB Device (status is ignored for code simplicity) */</span></div><div class="line">(void) <a class="code" href="group__group__usb__dev__functions__common.html#ga12b36659b72aa85166e85323eb96e36a">Cy_USB_Dev_Init</a>(USBD_HW, &amp;USBD_config, &amp;USBD_drvContext, </div><div class="line">                         &amp;usb_devices[0], &amp;usb_devConfig, &amp;USBD_devContext);</div><div class="line"></div><div class="line"><span class="comment">/* Initialize requires USB Device Classes (status is ignored for code simplicity) */</span></div><div class="line">(void) <a class="code" href="group__group__usb__dev__audio__functions.html#ga8224694c94d72e5c3e2d717bd3a70f3c">Cy_USB_Dev_Audio_Init</a>(NULL, &amp;USBD_audioContext, &amp;USBD_devContext);</div><div class="line">(void) <a class="code" href="group__group__usb__dev__cdc__functions.html#ga674860e659c0f23538a9f6c11e64b03a">Cy_USB_Dev_CDC_Init</a>(&amp;usb_cdcConfig, &amp;USBD_cdcContext, &amp;USBD_devContext);</div><div class="line">(void) <a class="code" href="group__group__usb__dev__hid__functions.html#ga96ac1be9fe988572712f3111180170bb">Cy_USB_Dev_HID_Init</a>(&amp;usb_hidConfig, &amp;USBD_hidContext, &amp;USBD_devContext);</div><div class="line"></div><div class="line"><span class="comment">/* Hook interrupt service routines */</span></div><div class="line">(void) Cy_SysInt_Init(&amp;USBD_IntrLowConfig,    &amp;USBD_IsrLow);</div><div class="line">(void) Cy_SysInt_Init(&amp;USBD_IntrMeduimConfig, &amp;USBD_IsrMedium);</div><div class="line">(void) Cy_SysInt_Init(&amp;USBD_IntrHighConfig,   &amp;USBD_IsrHigh);</div><div class="line"></div><div class="line"><span class="comment">/* Enable interrupts */</span></div><div class="line">NVIC_EnableIRQ((IRQn_Type) USBD_IntrLowConfig.intrSrc);</div><div class="line">NVIC_EnableIRQ((IRQn_Type) USBD_IntrMeduimConfig.intrSrc);</div><div class="line">NVIC_EnableIRQ((IRQn_Type) USBD_IntrHighConfig.intrSrc);</div><div class="line"></div><div class="line"><span class="comment">/* Enable global interrupts */</span></div><div class="line">__enable_irq();</div><div class="line"></div><div class="line"><span class="comment">/* Make USB device appear on the bus */</span></div><div class="line"><a class="code" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a>(<span class="keyword">true</span>, <a class="code" href="group__group__usb__dev__macros.html#gad8a978b86bb53dd8e46d9f9db9399ee8">CY_USB_DEV_WAIT_FOREVER</a>, &amp;USBD_devContext);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The interrupts are mandatory for the USB Device operation. Therefore, USBFS interrupts must be enabled in the NVIC and global interrupts must be enabled as well.</dd></dl>
<h1><a class="anchor" id="section_usb_dev_design"></a>
Design Considerations</h1>
<p>The typical use case is that application calls the middleware API interface provided by the USB Device or Class layer to implement application logic. However, some features are provided only by the USBFS driver layer. Therefore, if the application needs them, the driver API interface must be used. The list of these features is provided in the section <a class="el" href="index.html#group_usb_dev_drv_features">Driver Features</a>.</p>
<h2><a class="anchor" id="group_usb_dev_cfg_tool"></a>
USB Configurator</h2>
<p>The standalone USB Configurator tool helps construct USB Device descriptors. The USB device descriptors provide to the USB Host complete information about the connected device. The tool output are generated source and header files that contain information about the USB Device: device descriptors plus structures that help access device descriptors. Generated files are mandatory for the middleware operation and must be added to your project. The header file provides access to instances of the USB Device configuration structure <a class="el" href="structcy__stc__usb__dev__config__t.html">cy_stc_usb_dev_config_t</a> and array of the USB Device structures <a class="el" href="structcy__stc__usb__dev__device__t.html">cy_stc_usb_dev_device_t</a>. Both these definitions are required for USB Device configuration. The tool also generates instances of configuration structures required for CDC and HID Class configuration.</p>
<p>A detailed information about USB Descriptors is provided by the <a href="http://www.usb.org/developers/docs/usb20_docs/">USB Specification</a></p>
<p>The USB Configurator tool provides the User Guide, which can be found in the documentation.</p>
<h2><a class="anchor" id="group_usb_dev_std_requests"></a>
Standard Request Support</h2>
<p>The USB Device supports standard requests listed in the table below.</p>
<table class="doxtable">
<tr>
<th>Standard Request</th><th>Request Processing Description</th><th>USB Spec Reference </th></tr>
<tr>
<td>CLEAR_FEATURE </td><td>Clears or disables a specific feature. Support recipients: Device, Interface and Endpoint. The TEST_MODE feature selector is not supported. </td><td>9.4.1  </td></tr>
<tr>
<td>GET_CONFIGURATION </td><td>Returns the current device configuration value. </td><td>9.4.2  </td></tr>
<tr>
<td>GET_DESCRIPTOR </td><td>Returns the specified descriptor if the descriptor exists. </td><td>9.4.3  </td></tr>
<tr>
<td>GET_INTERFACE </td><td>Returns the selected alternate interface setting for the specified interface. </td><td>9.4.4  </td></tr>
<tr>
<td>GET_STATUS </td><td>Returns status for the specified recipient. Support recipients: Device, Interface, and Endpoint. </td><td>9.4.5  </td></tr>
<tr>
<td>SET_ADDRESS </td><td>Sets the device address for all future device accesses. </td><td>9.4.6  </td></tr>
<tr>
<td>SET_CONFIGURATION </td><td>Sets the device configuration. After this request, the device is ready for communication. </td><td>9.4.7  </td></tr>
<tr>
<td>SET_DESCRIPTOR </td><td>Not supported (optional request). </td><td>9.4.8  </td></tr>
<tr>
<td>SET_FEATURE </td><td>Enables a specific feature. Support recipients: Device, Interface, and Endpoint. The TEST_MODE feature selector is not supported. </td><td>9.4.9  </td></tr>
<tr>
<td>SET_INTERFACE </td><td>Allows the USB Host to select an alternate setting for the specified interface. </td><td>9.4.10  </td></tr>
<tr>
<td>SYNCH_FRAME </td><td>Not supported. </td><td>9.4.11  </td></tr>
</table>
<h2><a class="anchor" id="group_usb_dev_audio_class_info"></a>
Audio Class</h2>
<p>The USB Audio class can be used in a large amount of applications, either Made for iPod (MFI) or general USB Audio based. These applications consist of, but are not limited to, speakers, microphones, headsets, music creation tools (DJ equipment, guitar jacks, etc), and mixers. An additional application for the Audio class is in Musical Instrument Digital Interface (MIDI) applications. This interface uses a digital UART-like interface and allows the information to be sent across to the Host to be used with software applications, such as Apple Garage Band. Various instruments, such as electronic pianos, interface with MIDI.</p>
<p>A detailed description about Audio Class is provided by the <a href="http://www.usb.org/developers/docs/devclass_docs/">USB Implementers Forum (USB-IF) Class Documentation</a></p>
<p>The Audio Class does not provide support any of Audio v1.0 or v2.0 requests processing and provides only the API interface to register Audio request handlers implemented on the application level. However, <a class="el" href="index.html#group_usb_dev_cfg_tool">USB Configurator</a> supports Audio v1.0 or v2.0 descriptors.</p>
<dl class="section note"><dt>Note</dt><dd>The MIDI Class support is not available in this version.</dd></dl>
<h2><a class="anchor" id="group_usb_dev_cdc_class_info"></a>
CDC: Communication Device Class</h2>
<p>Common use case for this class in a PSoC design is to replace a legacy serial (RS232) COM port with a USB connection. This allows customers to use legacy serial software while updating the communication interface to something more readily available on today's computers. The type of data that might be streamed across USB can vary depending on the end application. This could be as simple as streaming raw ADC counts to an entire command protocol. Additionally, CDC is extremely useful for debug purposes. Users can easily develop a USB interface that can send and receive information across CDC. On the Host side, GUI applications are widely available to view the data being transmitted, such as TeraTerm, Terminal, or Hyper-Terminal (depending on version of Microsoft Windows).</p>
<p>A detailed description about CDC class is provided by the <a href="http://www.usb.org/developers/docs/devclass_docs/">USB Implementers Forum (USB-IF) Class Documentation</a></p>
<p>The CDC Class supports requests listed in the table below. </p><table class="doxtable">
<tr>
<th>Class Request</th><th>Request Processing Description</th><th>Communications Class Subclass Specification for PSTN Devices </th></tr>
<tr>
<td>SET_LINE_CODING </td><td>Allows the host to specify typical asynchronous line-character formatting properties such as: data terminal rate, number of stop bits, parity type and number of data bits. It applies to data transfers both from the Host to the Device and from the Device to the Host. </td><td>6.3.10  </td></tr>
<tr>
<td>GET_LINE_CODING </td><td>Allows the host to discover the currently configured line coding. </td><td>6.3.11  </td></tr>
<tr>
<td>SET_CONTROL_LINE_STATE </td><td>Generates RS-232/V.24 style control signals - RTS and DTR. </td><td>6.3.12  </td></tr>
</table>
<p>The CDC Class supports notifications listed in the table below. </p><table class="doxtable">
<tr>
<th>Class Notification</th><th>Notification Processing Description</th><th>Communications Class Subclass Specification for PSTN Devices </th></tr>
<tr>
<td>SERIAL_STATE </td><td>Allows the Host to read the current state of the carrier detect (CD), DSR, break, and ring signal (RI). </td><td>6.3.4  </td></tr>
</table>
<h2><a class="anchor" id="group_usb_dev_hid_class_info"></a>
HID: Human Interface Device</h2>
<p>There are many possible use cases for HID depending on the end application. A keyboard/keypad is a common HID application that has been implemented previously with PSoC. Additionally, customers can use PSoC to implement a PC mouse or game controller device. A more generic use case seen is with regards to customers using USB as general-purpose interface between PSoC and the Host, without conforming to specific USAGE such as a Keyboard, Mouse, etc. Instead the user configures the HID descriptor to be a generic device, which allows them to transfer Vendor-Specific information, such as ADC data, button presses, etc., across the HID protocol. This allows customers to perform custom/generic data transfers over USB, without needing to provide an INF or SYS file during enumeration or worry about WHQL certification. All this is accomplished using the HID drivers that are built into all modern operation systems today. This includes Windows, Mac, and Linux.</p>
<p>A detailed description about HID is provided by the <a href="http://www.usb.org/developers/docs/devclass_docs/">USB Implementers Forum (USB-IF) Class Documentation</a></p>
<p>The HID Class supports requests listed in the table below. </p><table class="doxtable">
<tr>
<th>Class Request</th><th>Request Processing Description</th><th>HID Spec Reference </th></tr>
<tr>
<td>GET_REPORT </td><td>Allows the USB Host to receive a report via the control pipe. </td><td>7.2.1  </td></tr>
<tr>
<td>SET_REPORT </td><td>Allows the USB Host to send a report via the control pipe (set a state of input, output, or feature report controls). </td><td>7.2.2  </td></tr>
<tr>
<td>GET_IDLE </td><td>Reads the current idle rate for a particular Input report. <br />
 The recommended default idle rate (rate when the device is initialized) is 500 milliseconds for keyboards (delay before first repeat rate) and infinity for joysticks and mice. </td><td>7.2.3  </td></tr>
<tr>
<td>SET_IDLE </td><td>Sets idle rate for a particular report. This request is used to limit the reporting frequency of an interrupt in endpoint.<br />
 When the idle rate byte is 0 (zero), the duration is indefinite. The endpoint reports only when a change is detected in the report data. When the idle rate byte is non-zero, then a fixed duration is used (defined by idle rate). </td><td>7.2.4  </td></tr>
<tr>
<td>GET_PROTOCOL </td><td>Reads which protocol is currently active (either the boot or the report protocol). </td><td>7.2.5  </td></tr>
<tr>
<td>SET_PROTOCOL </td><td>Switches between the boot protocol and the report protocol (or vice versa). </td><td>7.2.6  </td></tr>
</table>
<h2><a class="anchor" id="group_usb_dev_class_x"></a>
Adding Custom Class</h2>
<p>The USB Device middleware provides API interface that allows the user to implement custom class support. The middleware notifies registered class about following events:</p><ul>
<li>Bus Reset detected ( <a class="el" href="group__group__usb__dev__structures__func__ptr.html#gab6f8a0de15b09fe6a39e6d8032069a62">cy_cb_usb_dev_bus_reset_t</a> ).</li>
<li>Set Configuration request received ( <a class="el" href="group__group__usb__dev__structures__func__ptr.html#ga18e8445fcb1392dd424ae65a726c4bd6">cy_cb_usb_dev_set_config_t</a> ).</li>
<li>Set Interface request received ( <a class="el" href="group__group__usb__dev__structures__func__ptr.html#gaba4c41daa173f3dfc3a60c2260d1f0c1">cy_cb_usb_dev_set_interface_t</a> ).</li>
<li>Setup packet received ( <a class="el" href="group__group__usb__dev__structures__func__ptr.html#ga3a7649a1c575110ac8e4480d70da8c2c">cy_cb_usb_dev_request_received_t</a> ).</li>
<li>Data is received in response for current setup packet ( <a class="el" href="group__group__usb__dev__structures__func__ptr.html#ga626db28aeab6dfd0f7004866225bb0ee">cy_cb_usb_dev_request_cmplt_t</a> ).</li>
</ul>
<p>To create a new custom Class, follow the steps below:</p><ol type="1">
<li>Implement functions to service events (from the list above) required for class operation. Typically, class should implement service of class-specific requests therefore needs to implement functions defined by <a class="el" href="group__group__usb__dev__structures__func__ptr.html#ga3a7649a1c575110ac8e4480d70da8c2c">cy_cb_usb_dev_request_received_t</a> and <a class="el" href="group__group__usb__dev__structures__func__ptr.html#ga626db28aeab6dfd0f7004866225bb0ee">cy_cb_usb_dev_request_cmplt_t</a>.</li>
<li>Initialize instance of <a class="el" href="structcy__stc__usb__dev__class__t.html">cy_stc_usb_dev_class_t</a> structure using implemented service functions. Provide NULL pointer as function pointer if class does not use this event.</li>
<li>Allocate instance of <a class="el" href="structcy__stc__usb__dev__class__ll__item__t.html">cy_stc_usb_dev_class_ll_item_t</a> structure to provide storage for a linked list item of the class.</li>
<li>The class might need a context to store class-specific data. If needed, define context type specific for this class and allocate it.</li>
<li>To enable class operation, this needs to be registered using <a class="el" href="group__group__usb__dev__functions__class__support.html#ga7796c2ddd1f1bb389cbad19acdeb5c9a">Cy_USB_Dev_RegisterClass</a> function after USB Device middleware is initialized.</li>
</ol>
<p>Any of supported classes can be taken as an example to implement a custom class.</p>
<h2><a class="anchor" id="group_usb_dev_vendor"></a>
Vendor-Specific Requests Support</h2>
<p>The vendor-specific requests are STALLed by USB Device middleware by default. The exception is MS OS String vendor-specific request to retrieve an OS Feature Descriptor (Note that USB device must contain MS OS String descriptor to handle this vendor-specific by middleware). The middleware provides the <a class="el" href="group__group__usb__dev__functions__vendor__support.html#gad864982cf48ad57727e40d9e9fc3e239">Cy_USB_Dev_RegisterVendorCallbacks</a> function to register callbacks to handle vendor-specific requests.</p>
<h2><a class="anchor" id="group_usb_dev_ep_buf_alloc"></a>
Allocate Data Endpoint Buffer</h2>
<p>The application allocates buffers for data endpoints to operate. The buffer allocation depends on USBFS driver endpoint buffer access type configuration. It specifies which hardware register set 8-bit or 16-bit is used to access hardware endpoints buffer. The 16-bit access requires that the specific rules for the endpoints buffer allocation must be met (See Hardware Buffer Access section of the USBFS driver for more information). <br />
To make endpoint buffer allocation configuration independent, use the <a class="el" href="group__group__usb__dev__macros.html#ga0ccd70a937ab3d69aeb40030713bc69b">CY_USB_DEV_ALLOC_ENDPOINT_BUFFER</a> macro.</p>
<h2><a class="anchor" id="group_usb_dev_self_powered_dev"></a>
Self-Powered Devices</h2>
<p>The USB Device responds to GET_STATUS requests based on the status set with the <a class="el" href="group__group__usb__dev__functions__service.html#ga082afaccf8f10762300cfb1c996290fc">Cy_USB_Dev_SetPowerStatus</a> function. To set the correct status, <a class="el" href="group__group__usb__dev__functions__service.html#ga082afaccf8f10762300cfb1c996290fc">Cy_USB_Dev_SetPowerStatus</a> must be called during initialization if USB Device is configured as self-powered. The <a class="el" href="group__group__usb__dev__functions__service.html#ga082afaccf8f10762300cfb1c996290fc">Cy_USB_Dev_SetPowerStatus</a> must be called any time the device changes status. A self-powered device also requires monitoring VBUS to control pull-up resistors. The pull-up resistor does not supply power to the data line until you call <a class="el" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a>. <a class="el" href="group__group__usb__dev__functions__common.html#ga15cde7caa00a43d253198ea70935e47c">Cy_USB_Dev_Disconnect</a> disconnects the pull-up resistor from the data line. Find information about how to add VBUS monitoring in your application in the USBFS driver section VBUS Detection in the PDL API Reference Manual.</p>
<h2><a class="anchor" id="group_usb_dev_std_timeout"></a>
Timeout Function Redefinition</h2>
<p>The USB Device middleware provides following blocking functions: <a class="el" href="group__group__usb__dev__functions__data__transfer.html#ga0ffcc053f1154d6f77b1744f7a517ef5">Cy_USB_Dev_ReadEpBlocking</a>, <a class="el" href="group__group__usb__dev__functions__data__transfer.html#ga1bf916540d58d458568b2eed1a186df4">Cy_USB_Dev_WriteEpBlocking</a>, and <a class="el" href="group__group__usb__dev__functions__common.html#ga368f2e081a58b7eef81a17c4781fca8e">Cy_USB_Dev_Connect</a> (the behavior defined by the blocking parameter of the connect function). The blocking functions parameter timeout defines how many milliseconds to wait before timeout. The SysLib driver function Cy_SysLib_Delay is used to implement a 1 millisecond wait cycle. The middleware provides function <a class="el" href="group__group__usb__dev__functions__data__transfer.html#ga17873db332970f17f9cfa8b7f383c019">Cy_USB_Dev_OverwriteHandleTimeout</a> that allows overriding the wait function implementation. This might be useful when an operation system is used in your application.</p>
<dl class="section note"><dt>Note</dt><dd>The blocking function must be used carefully to not cause application lock-up. The preferred solution is using non-blocking functions.</dd></dl>
<h2><a class="anchor" id="group_usb_dev_drv_features"></a>
Driver Features</h2>
<p>There are driver features that do not have corresponding an API interface provided in the middleware. However, the application might need these features for USB Device implementation. If there is such a need, the driver functions must be used. These features are listed below:</p><ul>
<li>Data Endpoint 1 - 8 Completion, SOF received and LPM transfer ACKed events notification.</li>
<li>Low power support: Suspend / Resume, Remote wakeup signaling.</li>
<li>Link Power Management (LPM) support.</li>
</ul>
<p>Find more information in the appropriate section of the USBFS driver documentation provided in the PDL API Reference Manual.</p>
<h1><a class="anchor" id="section_usb_dev_toolchain"></a>
Supported Software and Tools</h1>
<p>For supported software and tools, refer to the Supported Software and Tools section in in the <a href="https://github.com/Infineon/usbdev/blob/master/RELEASE.md#supported-software-and-tools">RELEASE.md</a></p>
<h1><a class="anchor" id="section_usb_dev_errata"></a>
Errata</h1>
<p>This section lists the known problems with the USB Device middleware.</p>
<table class="doxtable">
<tr>
<th>Cypress ID</th><th>Known Issue</th><th>Workaround </th></tr>
<tr>
<td>DRIVERS-1401 </td><td>The USB Device ignores LPM requests after wake up from Deep Sleep.  </td><td>Call USBFS driver Cy_USBFS_Dev_Drv_Lpm_SetResponse() after calling Cy_USBFS_Dev_Drv_Resume() to restore response to the LPM packets.   </td></tr>
<tr>
<td>DRIVERS-1427 </td><td>The USB Device modes with DMA do not work after wake up from Deep Sleep, due to incorrect restore of the ARB_CFG register.  </td><td>Save ARB_CFG values before entering Deep Sleep and restore it after calling of Cy_USBFS_Dev_Drv_Resume. <div class="fragment"><div class="line">    <span class="comment">/* Read and save value of ARB_CFG register </span></div><div class="line"><span class="comment">     * USBD_HW is a pointer to the base address of USBFS Device */</span></div><div class="line">    uint32_t tempReg = USBFS_DEV_ARB_CFG(USBD_HW);</div><div class="line">    </div><div class="line">    <span class="comment">/* Entering Deep Sleep */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Resume after Deep Sleep */</span></div><div class="line">    Cy_USBFS_Dev_Drv_Resume(USBD_HW, &amp;USBD_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Restore ARB_CFG register after deep sleep */</span></div><div class="line">    USBFS_DEV_ARB_CFG(USBD_HW) &amp;= (~USBFS_USBDEV_ARB_CFG_CFG_CMP_Msk);</div><div class="line">    USBFS_DEV_ARB_CFG(USBD_HW) = tempReg;</div><div class="line">    (void) USBFS_DEV_ARB_CFG(USBD_HW);</div><div class="line"></div></div><!-- fragment -->   </td></tr>
</table>
<h1><a class="anchor" id="group_usb_dev_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="4">2.10 </td><td>Updated Documentation </td><td>PMG1 Integration  </td></tr>
<tr>
<td>Fixed vendor request handling </td><td>Defect Fixes  </td></tr>
<tr>
<td>Added support for configurations without any data endpoints </td><td>Defect Fixes   </td></tr>
<tr>
<td>Minor enhancements in several functions. </td><td>Enabled compliance with MISRA-C:2012 standard.   </td></tr>
<tr>
<td rowspan="5">2.0 </td><td>Updated the internal processing to support USBFS driver updates. </td><td>The USBFS driver is updated to v2.0.  </td></tr>
<tr>
<td>Moved the timeout from <a class="el" href="group__group__usb__dev__functions__data__transfer.html#gafe804a021cfbea888a966b8cf1b4172e" title="Aborts pending read or write endpoint operation. ">Cy_USB_Dev_AbortEpTransfer()</a> to the driver layer. The maximum function's wait time is significantly reduced. </td><td>Align with the changes of the USBFS driver.  </td></tr>
<tr>
<td>Changed the functions parameter name and the structure member name class to classObj. </td><td>Fixed the ambiguity related to the usage of the C++ keyword class as a name.  </td></tr>
<tr>
<td>Enclosed middleware sources within a conditional compilation to exclude the USB Device middleware for devices without USB hardware. </td><td>Fixed a compilation error for devices without USB hardware.  </td></tr>
<tr>
<td>Updated the major and minor version defines to follow the naming convention. </td><td></td></tr>
<tr>
<td>1.0 </td><td>The initial version. </td><td></td></tr>
</table>
<h1><a class="anchor" id="group_usb_dev_more_information"></a>
More Information</h1>
<p>For more information, refer to the links in the <a href="https://github.com/Infineon/usbdev/blob/master/README.md#more-information">README.md</a></p>
<dl class="section note"><dt>Note</dt><dd>The links to the other software component's documentation (middleware and PDL) point to GitHub to the software latest available version. To get documentation of the specified version, download from GitHub and unzip the component archive. The documentation is available in the <em>docs</em> folder. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>USB Device Middleware Library 2.10</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
